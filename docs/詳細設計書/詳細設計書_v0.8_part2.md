# 時系列オッズ取得アプリ 詳細設計書 v0.8 (Part 2/2)

**文書バージョン**: 0.8  
**作成日**: 2025-12-23  
**最終更新日**: 2025-12-23  
**ステータス**: 現行版

**前編からの続き**

---

## 6. import_from_target.py 設計

### 6.1 概要

ターゲットソフトウェアからエクスポートしたCSVファイルをインポートするモジュール。

### 6.2 クラス: TargetCSVImporter

#### 6.2.1 コンストラクタ

```python
def __init__(self, db_path='data/odds_history.db'):
    self.db_path = db_path
    self.conn = sqlite3.connect(db_path)
    self.cursor = self.conn.cursor()
    self.stats = {
        'total_files': 0,
        'total_races': 0,
        'total_odds_records': 0,
        'errors': 0
    }
```

#### 6.2.2 メソッド一覧

| メソッド名 | 説明 |
|:---|:---|
| `parse_race_id(race_id_str)` | レースIDをパース |
| `parse_timestamp(race_info, time_str)` | タイムスタンプ変換 |
| `get_ba_name(ba_code)` | 競馬場コードから競馬場名を取得 |
| `import_csv(csv_path)` | CSVファイルをインポート |
| `import_directory(pattern)` | 複数CSVファイルを一括インポート |
| `print_summary()` | インポート結果サマリーを表示 |
| `close()` | データベース接続を閉じる |

#### 6.2.3 parse_race_id(race_id_str)

**目的**: レースIDをパースして構造化情報を取得

**引数**: race_id_str (例: "2025120607050101")

**戻り値**: dict
```python
{
    'year': '2025',
    'month': '12',
    'day': '06',
    'date': '2025-12-06',
    'ba_code': '07',
    'kai': '05',
    'nichi': '01',
    'race_no': '01'
}
```

**処理**:
1. 年月日(8桁)を抽出
2. 競馬場コード(2桁)を抽出
3. 回次(2桁)を抽出
4. 日次(2桁)を抽出
5. レース番号(2桁)を抽出
6. 日付を`YYYY-MM-DD`形式に変換

#### 6.2.4 parse_timestamp(race_info, time_str)

**目的**: 月日時分を完全なタイムスタンプに変換

**引数**:
- race_info: parse_race_id()の戻り値
- time_str: "12051831" (MMDDHHMM形式)

**戻り値**: str (例: "2025-12-05 18:31")

**処理**:
1. 月(2桁)を抽出
2. 日(2桁)を抽出
3. 時(2桁)を抽出
4. 分(2桁)を抽出
5. race_infoの年と組み合わせて完全なタイムスタンプを生成

#### 6.2.5 get_ba_name(ba_code)

**目的**: 競馬場コードから競馬場名を取得

**マッピング**:
```python
ba_names = {
    '01': '札幌', '02': '函館', '03': '福島', '04': '新潟',
    '05': '東京', '06': '中山', '07': '中京', '08': '京都',
    '09': '阪神', '10': '小倉'
}
```

#### 6.2.6 import_csv(csv_path)

**目的**: 単一CSVファイルをインポート

**処理フロー**:
1. CSVファイルをShift-JISで開く
2. ヘッダー行を読み込み、レースIDを抽出
3. レースIDをパースして構造化情報を取得
4. 競馬場名を取得
5. レース名を生成: `{競馬場名}{回次}回{日次}日{レース番号}R`
6. racesテーブルにINSERT OR REPLACE
7. データ行をループ:
   - 1列目: タイムスタンプ(MMDDHHMM)
   - 2列目以降: 馬番ごとのオッズ(ワイド形式)
   - タイムスタンプを変換
   - 各馬番のオッズを抽出してodds_historyテーブルにINSERT
8. コミット
9. 統計情報を更新

**CSVフォーマット例**:
```csv
2025120607050101,,,,,,,,,,,,,,,,,,,
12051831,3.5,4.2,5.1,2.8,...
12051845,3.6,4.1,5.0,2.9,...
```

#### 6.2.7 import_directory(pattern)

**目的**: ワイルドカード指定で複数CSVファイルを一括インポート

**引数**: pattern (例: "target系/*.CSV")

**処理**:
1. glob.glob()でファイルリストを取得
2. 各ファイルに対してimport_csv()を実行
3. エラー発生時はエラーカウントを増やして継続

#### 6.2.8 print_summary()

**目的**: インポート結果のサマリーを表示

**出力例**:
```
========================================
インポート完了
========================================
処理ファイル数: 5
総レース数: 60
総オッズレコード数: 108,000
エラー数: 0
========================================
```

---

## 7. realtime_monitor.py 設計

### 7.1 概要

JV-LinkのJVRTOpen APIを使用してリアルタイムオッズを監視するモジュール。

### 7.2 クラス: RealtimeOddsMonitor

#### 7.2.1 コンストラクタ

```python
def __init__(self, service_key="UNKNOWN"):
    self.service_key = service_key
    self.jvlink = None
    self.is_monitoring = False
```

#### 7.2.2 メソッド一覧

| メソッド名 | 説明 |
|:---|:---|
| `connect()` | JV-Linkへの接続 |
| `start_monitoring(data_types)` | リアルタイム監視開始 |
| `_monitor_loop()` | 監視ループ |
| `stop_monitoring()` | 監視停止 |

#### 7.2.3 connect()

**処理**: collector.pyと同様

#### 7.2.4 start_monitoring(data_types="0B31")

**目的**: リアルタイム監視を開始

**引数**: data_types (データ種別)
- 0B12: 速報オッズ(単勝・複勝)
- 0B31: オッズ(単勝・複勝)リアルタイム
- 0B32-0B37: その他のオッズ種別

**処理フロー**:
1. 監視対象日を取得(当日): `datetime.now().strftime("%Y%m%d")`
2. JVRTOpen(data_types, key)を実行
3. 戻り値が0の場合、`_monitor_loop()`を呼び出す
4. エラーの場合、エラーメッセージを表示

#### 7.2.5 _monitor_loop()

**目的**: リアルタイムデータを継続的に取得

**処理フロー**:
1. JVDataParserインスタンスを作成
2. 無限ループ:
   - バッファサイズ50,000 Byteのbytearray作成
   - JVGets(buff, buff_size)を実行
   - 戻り値チェック:
     - 0: データなし、1秒待機
     - -1: ファイル切り替え、継続
     - 正の値: データ取得成功
   - データをShift-JISでデコード
   - レコードタイプ判定(先頭2文字)
   - レコードタイプラベルを取得:
     ```python
     type_labels = {
         "O1": "単勝オッズ",
         "O2": "複勝オッズ",
         "O3": "枠連オッズ",
         "O4": "馬連オッズ",
         "O5": "ワイドオッズ",
         "O6": "馬単オッズ",
         "SE": "成績データ",
         "RA": "レース情報",
         "HR": "払戻金",
         "JC": "騎手変更",
         "TC": "調教師変更",
     }
     ```
   - タイムスタンプ付きでコンソール出力
   - オッズレコード(O1-O7)の場合、パーサーで解析
   - コミット
3. Ctrl+C または例外発生時、ループを抜ける
4. `stop_monitoring()`を呼び出す

#### 7.2.6 stop_monitoring()

**処理**:
1. JVClose()を実行
2. `is_monitoring = False`
3. メッセージを表示

---

## 8. api_server.py 設計

### 8.1 概要

Flask RESTful APIサーバーを提供するモジュール。

### 8.2 設定

```python
app = Flask(__name__, static_folder='../web', static_url_path='')
CORS(app)
DB_PATH = 'data/odds_history.db'
```

### 8.3 ヘルパー関数

#### get_db_connection()

**目的**: データベース接続を取得

**処理**:
```python
conn = sqlite3.connect(DB_PATH)
conn.row_factory = sqlite3.Row
return conn
```

**row_factory**: クエリ結果を辞書形式で取得可能にする

### 8.4 エンドポイント設計

#### GET /

**目的**: トップページを表示

**処理**: `web/index.html` を返す

#### GET /api/stats

**目的**: ダッシュボード統計情報を取得

**SQL**:
```sql
-- レース総数
SELECT COUNT(*) as count FROM races

-- オッズ記録総数
SELECT COUNT(*) as count FROM odds_history

-- 最終更新時刻
SELECT MAX(time_stamp) as last_time FROM odds_history
```

**レスポンス**: JSON
```json
{
  "total_races": 1234,
  "total_odds": 567890,
  "monitor_status": "停止中",
  "last_update": "2025-12-23 15:30:45"
}
```

#### GET /api/races

**目的**: レース一覧を取得

**クエリパラメータ**:
- date: 開催日 (YYYY-MM-DD)
- ba_code: 競馬場コード

**SQL**:
```sql
SELECT * FROM races 
WHERE 1=1
  AND date = ? (dateが指定されている場合)
  AND ba_code = ? (ba_codeが指定されている場合)
ORDER BY date DESC, race_no ASC
```

**レスポンス**: JSON配列

#### GET /api/odds/<race_id>

**目的**: 特定レースのオッズ履歴を取得

**SQL**:
```sql
SELECT * FROM odds_history 
WHERE race_id = ? 
ORDER BY umaban, time_stamp
```

**レスポンス**: JSON配列

#### POST /api/fetch-historical

**目的**: 過去データ取得を開始

**リクエストボディ**:
```json
{
  "service_key": "YOUR_KEY",
  "days": 7
}
```

**処理**: TODO (現在は簡易実装、将来的にcollector.pyを別スレッドで実行)

#### POST /api/start-monitor

**目的**: リアルタイム監視を開始

**リクエストボディ**:
```json
{
  "data_type": "0B12"
}
```

**処理**: TODO (現在は簡易実装、将来的にrealtime_monitor.pyを別スレッドで実行)

#### POST /api/stop-monitor

**目的**: リアルタイム監視を停止

**処理**: TODO (監視スレッドを停止)

#### GET /api/export-csv

**目的**: データをCSV形式でエクスポート

**SQL**:
```sql
SELECT 
    oh.race_id,
    r.race_name,
    r.date,
    oh.time_stamp,
    oh.umaban,
    oh.odds_tan,
    oh.odds_fuku_min,
    oh.odds_fuku_max,
    oh.popularity
FROM odds_history oh
LEFT JOIN races r ON oh.race_id = r.race_id
ORDER BY oh.race_id, oh.umaban, oh.time_stamp
```

**レスポンス**: CSV形式ファイル (UTF-8 BOM付き)

**ヘッダー**:
```csv
レースID,レース名,日付,時刻,馬番,単勝オッズ,複勝下限,複勝上限,人気
```

---

## 9. Webダッシュボード設計 (web/)

### 9.1 ファイル構成

- `index.html`: メインHTML
- `styles.css`: スタイルシート
- `app.js`: JavaScript (Chart.js使用)

### 9.2 画面構成

#### 9.2.1 ナビゲーション

- ダッシュボード
- レース一覧
- オッズ分析
- 設定

#### 9.2.2 ダッシュボード画面

**統計カード**:
- 総レース数
- 総オッズレコード数
- 監視ステータス
- 最終更新時刻

**グラフ**:
- リアルタイムオッズ推移 (Chart.js Line Chart)

#### 9.2.3 レース一覧画面

**検索フィルター**:
- 開催日 (input type="date")
- 競馬場 (select)

**レース一覧テーブル**:
- レースID
- レース名
- 開催日
- 発走時刻
- アクション(詳細ボタン)

#### 9.2.4 オッズ分析画面

**入力**:
- レースID (input type="text")
- 検索ボタン

**グラフ**:
- 馬番ごとの時系列オッズ推移 (Chart.js Line Chart)
- X軸: 時刻
- Y軸: オッズ
- 凡例: 馬番

#### 9.2.5 設定画面

**データ取得設定**:
- サービスキー (input type="password")
- 取得日数 (input type="number")
- 取得開始ボタン

**リアルタイム監視設定**:
- データ種別 (select)
- 監視開始ボタン
- 監視停止ボタン

**エクスポート**:
- CSVエクスポートボタン

---

## 10. 起動スクリプト設計

### 10.1 アプリ起動.bat

**目的**: ユーザーフレンドリーなメニュー形式の起動インターフェース

**処理フロー**:
1. 文字コードをUTF-8に設定
2. カレントディレクトリをバッチファイルの場所に変更
3. メニュー表示:
   - [1] 過去データを取得する
   - [2] リアルタイム監視を開始する
   - [3] 設定ファイル(.env)を開く
   - [9] 終了
4. ユーザー選択に応じて処理:
   - 1: 仮想環境アクティベート → `python src/collector.py`
   - 2: 仮想環境アクティベート → `python src/realtime_monitor.py`
   - 3: `notepad .env`
   - 9: 終了

---

## 11. パラメータ設定

### 11.1 collector.py

| パラメータ | 値 | 説明 |
|:---|:---|:---|
| バッファサイズ | 40,000 Byte | JVGetsのバッファサイズ |
| レース間待機時間 | 0.6秒 | ドライバ安定性確保 |
| リトライ回数 | 3回 | エラー時の最大リトライ回数 |
| リトライ前待機時間 | 2.0秒 | リトライ前の待機時間 |
| コミット間隔 | 500レコード | データベースコミット間隔 |
| 再取得期間 | 30日 | この期間を超えたレースは再取得 |

### 11.2 realtime_monitor.py

| パラメータ | 値 | 説明 |
|:---|:---|:---|
| バッファサイズ | 50,000 Byte | JVGetsのバッファサイズ |
| ポーリング間隔 | 1秒 | データなし時の待機時間 |

### 11.3 待機時間の重要性

**検証結果**:

| 待機時間 | 結果 |
|:---|:---|
| 0.1秒 | JVGetsがハング、処理完全停止 |
| 0.3秒 | エラー発生(80レコードに1回程度) |
| **0.6秒** | **エラーなし、安定動作** ← 推奨値 |

**原因**:
JV-Link COMドライバは内部で非同期処理を行っており、連続呼び出しが速すぎると内部バッファやスレッド処理が追いつかず、ハングまたはエラーが発生する。

**結論**:
待機時間は**最低0.6秒**を推奨。処理速度よりも安定性を優先すること。

---

## 12. エラーハンドリング設計

### 12.1 JV-Linkエラーコード

| コード | 意味 | 対応 |
|:---|:---|:---|
| 0 | 成功 | 正常処理 |
| -1 | 汎用エラー | 即座にスキップ |
| -111 | 取得対象外 | 即座にスキップ |
| -203 | 該当データなし | 即座にスキップ |
| その他負の値 | エラー | リトライ |

### 12.2 例外処理

**基本方針**:
- 全ての外部API呼び出しはtry-exceptで囲む
- エラーログをコンソールに出力
- 可能な限り処理を継続

**例**:
```python
try:
    result = self.jvlink.JVOpen(...)
except Exception as e:
    print(f"[ERROR] JVOpen失敗: {e}")
    return False
```

---

## 13. セキュリティ設計

### 13.1 サービスキー管理

**方法**: 環境変数 `.env` ファイル

**例**:
```
JRAVAN_SERVICE_KEY=YOUR_SERVICE_KEY_HERE
```

**.gitignore**:
```
.env
```

**読み込み**:
```python
from dotenv import load_dotenv
import os

load_dotenv()
service_key = os.getenv("JRAVAN_SERVICE_KEY", "UNKNOWN")
```

### 13.2 データベースアクセス

- ローカルファイルベース
- 外部アクセス不可
- SQLインジェクション対策: プレースホルダー使用

**例**:
```python
cursor.execute('SELECT * FROM races WHERE race_id = ?', (race_id,))
```

### 13.3 Web APIアクセス

- localhost のみ
- CORS設定: 開発用に全許可、本番環境では制限推奨

---

## 14. テスト設計

### 14.1 単体テスト

**対象モジュール**:
- parser.py
- import_from_target.py

**テストケース例**:
- `_safe_float()`: 正常値、非数値、空文字列
- `parse_race_id()`: 正常なレースID、異常なレースID
- `parse_timestamp()`: 正常なタイムスタンプ、異常なタイムスタンプ

### 14.2 統合テスト

**シナリオ**:
1. データベース初期化
2. collector.pyで過去データ取得
3. データベース内容確認
4. import_from_target.pyでCSVインポート
5. データベース内容確認
6. Web APIでデータ取得
7. レスポンス確認

### 14.3 手動テスト

**チェックリスト**:
- [ ] JV-Link接続成功
- [ ] 過去データ取得成功
- [ ] リトライ機能動作確認
- [ ] クラッシュリカバリ動作確認
- [ ] ターゲットCSVインポート成功
- [ ] リアルタイム監視成功
- [ ] Webダッシュボード表示確認
- [ ] CSVエクスポート成功

---

## 15. 運用設計

### 15.1 初回セットアップ

1. Python 32bit版インストール
2. 仮想環境作成
3. 依存ライブラリインストール
4. JV-Link SDKインストール
5. `.env` ファイル作成、サービスキー設定
6. データベース初期化: `python src/init_db.py`

### 15.2 日常運用

**過去データ取得**:
1. `アプリ起動.bat` 実行
2. メニューから「1」を選択
3. 期間を入力
4. 自動的に取得開始

**リアルタイム監視**:
1. `アプリ起動.bat` 実行
2. メニューから「2」を選択
3. 監視開始
4. Ctrl+C で停止

**Webダッシュボード**:
1. `python src/api_server.py` 実行
2. ブラウザで `http://localhost:5000` にアクセス

### 15.3 トラブルシューティング

**問題**: JV-Link接続失敗

**対応**:
1. JV-Link SDKがインストールされているか確認
2. サービスキーが正しく設定されているか確認
3. インターネット接続を確認

**問題**: データ取得中にエラー

**対応**:
1. エラーログを確認
2. リトライ機能が動作しているか確認
3. 再起動して途中から再開

**問題**: Webダッシュボードが表示されない

**対応**:
1. api_server.pyが起動しているか確認
2. ブラウザのコンソールでエラーを確認
3. データベースにデータが存在するか確認

---

## 16. 性能最適化

### 16.1 データベース最適化

**インデックス**:
```sql
CREATE INDEX idx_odds_race_time ON odds_history (race_id, time_stamp)
```

**VACUUM**: 定期的に実行してデータベースを最適化
```sql
VACUUM;
```

### 16.2 メモリ最適化

**ガベージコレクション**:
```python
import gc
gc.collect()
```

**バッファサイズ**: 適切なサイズを設定(40,000-50,000 Byte)

---

## 17. 将来の拡張

### 17.1 機能拡張

- 馬連・馬単・3連複・3連単オッズの取得
- 機械学習モデルによるオッズ予測
- アラート機能(オッズ急変時に通知)
- スマートフォンアプリ

### 17.2 技術的改善

- マルチスレッド処理による高速化
- PostgreSQLへの移行(大規模データ対応)
- Docker化(環境構築の簡素化)
- CI/CD導入(自動テスト・デプロイ)

---

**文書終了**
