# 時系列オッズ取得アプリ 詳細設計書 v0.83

**文書バージョン**: 0.83  
**作成日**: 2025-12-23  
**最終更新日**: 2025-12-24  
**ステータス**: 現行版  
**前バージョン**: v0.82

---

## 1. 文書管理情報

### 1.1 改訂履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|:---|:---|:---|:---|
| 0.8 | 2025-12-23 | 初版作成。現在の実装を完全にドキュメント化 | System |
| 0.82 | 2025-12-23 | 複勝オッズ取得機能(O2レコード解析)を追加 | System |
| 0.83 | 2025-12-24 | DB書き込みボトルネック修正（WALモード、コミット戦略最適化） | System |


### 1.2 v0.82からの主な変更点（v0.83）

#### 問題の特定と修正
- **問題**: 96レース処理後、ドライバーリフレッシュ直後の103レース目で「データ読み込みエラー」が発生
- **根本原因**: トランザクションバッファオーバーフロー
  - コミットが500レコードごとにしか呼ばれず、96レース分のデータがメモリに蓄積
  - SQLiteのデフォルト設定（WALモード無効）によるロック競合

#### モジュール変更
- **parser.py**: WALモード有効化、PRAGMA最適化
  - `__init__`: WALモード設定を追加
  - デバッグprint文を削除
  
- **collector.py**: コミット戦略最適化、WALモード設定
  - `connect()`: WALモード設定を追加
  - `_read_jvdata()`: コミットタイミングを変更
    - RAレコード: 即座にコミット
    - Oレコード: 100件ごとにコミット（従来は500件ごと）
  
- **init_db.py**: WALモード初期設定
  - DB作成時からWALモードを有効化
  - パフォーマンスPRAGMA設定を追加

#### パフォーマンス改善
- トランザクションバッファ: 500レコード → 100レコード（80%削減）
- WALモードによる書き込み性能向上
- ロック競合の大幅軽減

### 1.3 v0.8からの主な変更点（v0.82）

#### モジュール変更
- **parser.py**: 複勝オッズ解析機能を追加
  - 新規メソッド: `_parse_fukusho_odds(data)`
  - 変更メソッド: `_parse_tansho_fukusho_odds()` を分離
  - **重要**: O2は別レコードではなく、「オッズ1(単複枠)」レコード内の複勝オッズ部

#### データフロー変更
- 「オッズ1(単複枠)」レコードから単勝部と複勝部の両方を解析
- 単勝部(オフセット43~)と複勝部(オフセット267~)を同一レコードから取得
- 同一タイムスタンプで単勝・複勝を同一レコードに保存


### 1.4 関連文書

- 要件定義書 v0.83
- JV-Data仕様書 Ver4.9.0.1
- JV-Link SDK ドキュメント

---

## 2. システムアーキテクチャ

(v0.8と同様のため省略)

---

## 3. データベース設計

(v0.8と同様のため省略)

**v0.82での変更点**:
- `odds_history` テーブルの `odds_fuku_min`, `odds_fuku_max` カラムに実際のデータを格納
- v0.8では0.0固定だったが、v0.82ではO2レコードから取得した実際の複勝オッズを保存

---

## 4. モジュール設計

### 4.1 ~ 4.2 init_db.py, parser.py (RAレコード、O1レコード)

(v0.8と同様のため省略)

### 4.3 parser.py - O2レコード解析 ★v0.82で新規追加

#### 4.3.1 parse_odds_record(data, rec_type) の変更

**v0.8**:
```python
def parse_odds_record(self, data, rec_type):
    try:
        if rec_type.startswith("O1"):
            self._parse_tansho_fukusho_odds(data)
        # 他のオッズタイプも同様に実装可能
    except Exception as e:
        pass
```

**v0.82**:
```python
def parse_odds_record(self, data, rec_type):
    try:
        if rec_type.startswith("O1"):
            # オッズ1(単複枠)レコード: 単勝部と複勝部の両方を解析
            self._parse_tansho_odds(data)
            self._parse_fukusho_odds(data)  # ★同一レコードから複勝部も解析
        # 他のオッズタイプも同様に実装可能
    except Exception as e:
        pass
```

**重要**: O2は別レコードタイプではなく、O1(オッズ1・単複枠)レコード内の複勝オッズ部分です。

#### 4.3.2 _parse_tansho_odds(data) の変更

**v0.8**: `_parse_tansho_fukusho_odds(data)`
**v0.82**: `_parse_tansho_odds(data)` にリネーム

**変更内容**:
- 複勝オッズの部分を削除
- 単勝オッズのみを処理

```python
def _parse_tansho_odds(self, data):
    """
    O1レコード(単勝オッズ)をパース
    """
    try:
        # レースキー取得
        race_key_year = data[11:15].decode('ascii', errors='ignore')
        race_key_month = data[15:17].decode('ascii', errors='ignore')
        race_key_day = data[17:19].decode('ascii', errors='ignore')
        race_key_ba = data[19:21].decode('ascii', errors='ignore')
        race_key_race_no = data[25:27].decode('ascii', errors='ignore')
        
        race_id = f"{race_key_year}{race_key_month}{race_key_day}{race_key_ba}{race_key_race_no}"
        
        # 発表時刻取得
        ann_month = data[27:29].decode('ascii', errors='ignore')
        ann_day = data[29:31].decode('ascii', errors='ignore')
        ann_hour = data[31:33].decode('ascii', errors='ignore')
        ann_min = data[33:35].decode('ascii', errors='ignore')
        timestamp = f"{race_key_year}-{ann_month}-{ann_day} {ann_hour}:{ann_min}"
        
        # 馬番ごとのオッズ
        offset = 43
        for i in range(28):
            umaban_str = data[offset:offset+2].decode('ascii', errors='ignore').strip()
            if not umaban_str or self._safe_int(umaban_str) == 0:
                break
            
            umaban = self._safe_int(umaban_str)
            tansho_str = data[offset+2:offset+6].decode('ascii', errors='ignore').strip()
            tansho_odds = self._safe_float(tansho_str) / 10
            popularity_str = data[offset+6:offset+8].decode('ascii', errors='ignore').strip()
            popularity = self._safe_int(popularity_str)
            
            # 単勝オッズのみ保存(複勝は0.0)
            self.cursor.execute('''
                INSERT INTO odds_history 
                (race_id, time_stamp, umaban, odds_tan, odds_fuku_min, odds_fuku_max, popularity)
                VALUES (?, ?, ?, ?, 0.0, 0.0, ?)
                ON CONFLICT(race_id, time_stamp, umaban) DO UPDATE SET
                odds_tan = excluded.odds_tan,
                popularity = excluded.popularity
            ''', (race_id, timestamp, umaban, tansho_odds, popularity))
            
            offset += 8
    except Exception as e:
        pass
```

#### 4.3.3 _parse_fukusho_odds(data) ★新規追加

**目的**: 複勝オッズ部をパースしてデータベースに保存

**重要**: これは「オッズ1(単複枠)」レコード内の複勝オッズ部分です。O2という別レコードタイプではありません。

**JV-Data構造** (JV-Data仕様書 Ver 4.9.0.1 に基づく):

**全体構造**:
```
オッズ1(単複枠)レコード:
├─ ヘッダ部
├─ 単勝オッズ部 (オフセット43~)
│   └─ 1頭8バイト × 28頭 = 224バイト
└─ 複勝オッズ部 (オフセット267~)
    └─ 1頭10バイト × 28頭 = 280バイト
```

**複勝オッズ部の構造** (1頭あたり10バイト):

| フィールド | サイズ | 型 | 説明 |
|:---|:---|:---|:---|
| 馬番 | 2 | ASCII | 01-28 |
| 複勝オッズ下限 | 4 | ASCII | 10倍値 (例: "0120" → 12.0倍) |
| 複勝オッズ上限 | 4 | ASCII | 10倍値 (例: "0180" → 18.0倍) |

> [!IMPORTANT]
> **データ順序に関する重要な注意**
> 
> JV-Data仕様書では「馬番 → 複勝オッズ（下限） → 複勝オッズ（上限）」と記載されていますが、
> **実際のデータでは下限が先、上限が後**です。
> 
> - offset+2~+6: **下限** (例: "0120" → 12.0倍)
> - offset+6~+10: **上限** (例: "0180" → 18.0倍)
> 
> この順序で読み取ることで、正しく「下限 < 上限」の関係が成り立ちます。

**オフセット計算**:
```python
TANSHO_START = 43  # 単勝オッズ部の開始位置
UMA_MAX = 28       # 最大頭数(仕様上の固定値)
TANSHO_BYTES_PER_HORSE = 8
FUKUSHO_BYTES_PER_HORSE = 10

# 複勝オッズ部の開始位置
FUKUSHO_START = TANSHO_START + (UMA_MAX * TANSHO_BYTES_PER_HORSE)
                = 43 + (28 * 8)
                = 267
```

**実装**:
```python
def _parse_fukusho_odds(self, data):
    """
    複勝オッズ部をパース
    
    注意: これは「オッズ1(単複枠)」レコード内の複勝オッズ部分です。
    JV-Data仕様書 Ver 4.9.0.1 に基づく実装。
    """
    try:
        # レースキー取得(単勝部と同じ)
        race_key_year = data[11:15].decode('ascii', errors='ignore')
        race_key_month = data[15:17].decode('ascii', errors='ignore')
        race_key_day = data[17:19].decode('ascii', errors='ignore')
        race_key_ba = data[19:21].decode('ascii', errors='ignore')
        race_key_race_no = data[25:27].decode('ascii', errors='ignore')
        
        race_id = f"{race_key_year}{race_key_month}{race_key_day}{race_key_ba}{race_key_race_no}"
        
        # 発表時刻取得(単勝部と同じ)
        ann_month = data[27:29].decode('ascii', errors='ignore')
        ann_day = data[29:31].decode('ascii', errors='ignore')
        ann_hour = data[31:33].decode('ascii', errors='ignore')
        ann_min = data[33:35].decode('ascii', errors='ignore')
        timestamp = f"{race_key_year}-{ann_month}-{ann_day} {ann_hour}:{ann_min}"
        
        # 複勝オッズ部の開始位置を計算
        TANSHO_START = 43
        UMA_MAX = 28
        FUKUSHO_START = TANSHO_START + (UMA_MAX * 8)  # = 267
        
        # 馬番ごとのオッズ
        offset = FUKUSHO_START
        
        for i in range(UMA_MAX):
            # 馬番 (2バイト)
            umaban_str = data[offset:offset+2].decode('ascii', errors='ignore').strip()
            if not umaban_str:
                break  # 馬番が空なら終了
            
            umaban = self._safe_int(umaban_str)
            if umaban == 0:
                break  # 馬番が0なら終了
            
            
            # 複勝オッズ下限 (4バイト、10倍値)
            fuku_min_str = data[offset+2:offset+6].decode('ascii', errors='ignore').strip()
            fuku_min = self._safe_float(fuku_min_str) / 10
            
            # 複勝オッズ上限 (4バイト、10倍値)
            fuku_max_str = data[offset+6:offset+10].decode('ascii', errors='ignore').strip()
            fuku_max = self._safe_float(fuku_max_str) / 10
            
            # データベースに保存
            # 同一(race_id, time_stamp, umaban)の場合はUPDATE
            self.cursor.execute('''
                INSERT INTO odds_history 
                (race_id, time_stamp, umaban, odds_tan, odds_fuku_min, odds_fuku_max, popularity)
                VALUES (?, ?, ?, 0.0, ?, ?, 0)
                ON CONFLICT(race_id, time_stamp, umaban) DO UPDATE SET
                odds_fuku_min = excluded.odds_fuku_min,
                odds_fuku_max = excluded.odds_fuku_max
            ''', (race_id, timestamp, umaban, fuku_min, fuku_max))
            
            offset += 10  # 次の馬へ
    except Exception as e:
        pass
```

**重要な注意事項**:
1. **別レコードではない**: 「オッズ1(単複枠)」レコード内の複勝オッズ部分
2. **同一タイムスタンプ**: 単勝部と複勝部は同じタイムスタンプで同一レコードに保存
3. **オフセット267**: 単勝部(43) + 28頭×8バイト = 267バイトから複勝部が開始
4. **10倍値**: 複勝オッズも単勝と同様に10倍値で格納されているため、10で割る
5. **仕様準拠**: JV-Data仕様書 Ver 4.9.0.1 に基づく正確な実装

> [!CAUTION]
> **ループ終了条件に関する重要な注意**
> 
> 馬番が0または空の場合、**`break`でループを終了**する必要があります。
> `continue`を使うと、offsetが進み続け、複勝オッズ以外のデータ（馬連、ワイド、枚連など）を
> 誤って読み取ってしまいます。
> 
> **理由**: O1レコード内では、複勝オッズ部の後に枚連オッズ部などが続きます。
> 実際の出走頭数が28頭未満の場合、複勝オッズ部は途中で終了し、
> 次のオッズ種別（枚連など）のデータが始まります。

---

## 5. collector.py 設計

(v0.8と同様のため省略)

**v0.82での変更点**:
- `_read_jvdata()` メソッド内で、O2レコードも `parser.parse_odds_record()` に渡す
- O1とO2の両方が解析される

---

## 6. ~ 17. その他のモジュール

(v0.8と同様のため省略)

---

## 18. 実装上の注意事項 ★v0.82で追加

### 18.1 O2レコードの仕様確認が必要

**確認が必要な項目**:
1. O2レコードのバイナリ構造(オフセット、サイズ)
2. 複勝オッズの格納形式(10倍値かどうか)
3. 1頭あたりのバイトサイズ
4. O1とO2の発表タイミングの違い

**確認方法**:
- `sdk/JRA-VAN Data Lab. SDK Ver4.9.0.2/ドキュメント/JV-Data仕様書_4.9.0.1.xlsx` を参照
- または Perplexity で最新の開発フォーラム情報を検索

### 18.2 データベースの競合処理

O1(単勝)とO2(複勝)は発表時刻が異なる可能性があるため、以下の戦略を採用:

**戦略1: 同一レコードに統合**
- 同一 `(race_id, time_stamp, umaban)` の場合、UPDATEで統合
- O1が先に来た場合: `odds_tan` のみ保存、複勝は0.0
- O2が先に来た場合: 複勝のみ保存、`odds_tan` は0.0
- 後から来た方でUPDATE

**戦略2: 別レコードとして保存**
- O1とO2で `time_stamp` が異なる場合、別レコードとして保存
- 分析時に最も近い時刻のデータを結合

**推奨**: 戦略1(同一レコードに統合)

### 18.3 テスト方法

1. **単体テスト**: O2レコードのサンプルデータでパース処理をテスト
2. **統合テスト**: 実際のJV-Linkから取得したデータで動作確認
3. **データ検証**: 複勝オッズが0.0以外で保存されていることを確認

---

**文書終了**

**次のアクション**:
O2レコードの正確な仕様を確認するため、以下のいずれかを実施:
1. `JV-Data仕様書_4.9.0.1.xlsx` を開いてO2レコードの構造を確認
2. Perplexity で最新の開発フォーラム情報を検索
