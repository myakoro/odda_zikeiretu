# JV-Data O2（複勝時系列オッズ）仕様整理メモ（JV-Data 4.9.0.1）

このメモは、2025年12月時点で確認できる **JV-Data仕様書 Ver 4.9.0.1** と関連資料にもとづき、O2相当（複勝時系列オッズ）の構造を整理したものです。

---

## 1. O2と「オッズ1（単複枠）」の関係

- JV-Data仕様書 4.9.0.1 では、「７．オッズ1（単複枠）」に **単勝・複勝・枠連** がセットで定義されている。
- 変更履歴では「オッズ1～5のオッズ部説明を追記」「繰り返し順序を追記」など、オッズ1（単複枠）内で完結する修正が行われている。
- データ種別一覧では、「時系列オッズ(単複枠) / 速報オッズ（単複枠）」が dataspec 0B41 として登録され、これに対してフォーマット「７．オッズ1（単複枠）」が紐付いている。

**結論:**  
O2 を「別フォーマット」とみなすのではなく、**オッズ1（単複枠）レコードのうち、時系列オッズ用として配信されるレコードの複勝オッズ部**と理解するのが正しい。

---

## 2. 複勝オッズ部（O2相当）のバイナリ構造

### 1頭あたりの構造・サイズ

仕様書「７．オッズ1（単複枠）」のオッズ部定義・変更履歴から、複勝オッズ部は次の 10 バイト固定長と読み取れる。

- 馬番: 2バイト（ASCII, "01"～"28"）
- 複勝オッズ下限: 4バイト（ASCII 数値）
- 複勝オッズ上限: 4バイト（ASCII 数値）

→ 1頭あたり **10バイト**（2 + 4 + 4）

### 格納形式（10倍値か）

- 仕様書ではオッズ1～5に共通して「オッズは小数第1位までを4桁の数字で表現」等の説明があり、単勝・複勝とも同じ表現ルールを使うことが明示されている。
- 各種 Viewer / 解説記事でも、単勝と同様に「10倍値を整数で保持して小数1位表示」と解説されている。

**結論:**  
- `"0120"` → 12.0倍
- `"0005"` → 0.5倍

という形で、複勝オッズ下限・上限も **10倍値の4桁ASCII** で格納される。

### 下限・上限の順序

- 変更履歴に「７．オッズ1(単複枠) オッズ部の繰り返し順序を追記」とあり、その本文で「馬番 → 複勝オッズ（下限） → 複勝オッズ（上限）」という順番が示されている。

**結論:**  
複勝オッズ部は、**「馬番 → 下限 → 上限」** の順で 10 バイトが頭数分並ぶ。

---

## 3. オフセット（開始位置）の考え方

### 全体構造イメージ（オッズ1・単複枠）

仕様書では、バイト位置ではなく「項番＋桁数」で構造が定義されている。
概略は次のとおり:

- ヘッダ部:
  - レコード種別 ID（2バイト）
  - データ区分、作成年月日、開催情報、レースキー、フラグ類 など
- 単勝オッズ部:
  - 1頭あたり 8バイト（馬番2 + 単勝オッズ4 + 人気順2）が最大頭数分（仕様上28）並ぶ。
- 複勝オッズ部:
  - 1頭あたり 10バイト（馬番2 + 複勝下限4 + 複勝上限4）が同じく最大頭数分並ぶ。
- その後に枠連オッズ部などが続く。

### 実装上の計算

O1 の解析実装で「単勝オッズ部先頭がオフセット 43」と確認できているのであれば、複勝は:

```
複勝部先頭オフセット
= 単勝部先頭オフセット + (1頭あたり8バイト × 最大頭数)
= 43 + 8 * 28
= 267
```

**ポイント:**
- 解析では「最大頭数（仕様上28）」を使って次のブロック先頭を計算する方が安全。
- 実際の出走頭数が少なくても、仕様上は最大頭数ぶんの領域が確保されている前提で次のブロックが始まる設計になっているため。

---

## 4. O1 vs O2（時系列）の関係・取得方法

### 発表・更新タイミング

- データ種別一覧と各種ソフトの説明では、「時系列オッズ(単複枠)」は単勝・複勝・枠連のセットとして一定間隔（開催当日5～10分程度）で配信されると説明されている。
- TARGET や Viewer の説明でも「単複枠の時系列オッズをまとめて取得して表示」とあり、単勝と複勝が意図的に別タイミングで配信されるとは書かれていない。

**結論:**  
- **仕様上は単勝・複勝・枠連が同一スナップショットとして同時に更新される想定。**
- 実装・ネットワーク次第で「見かけ上の数秒差」が出る可能性はあるが、それはアプリ側の処理の問題であって仕様ではない。

### dataspec とレコード種別

- dataspec 0B41 は「速報オッズ（単複枠）/時系列オッズ（単複枠）」として登録され、フォーマットは「７．オッズ1（単複枠）」が割り当てられている。
- 開発者記事やフォーラムでも「時系列オッズを使うには 0B41 を開き、オッズ1（単複枠）フォーマットで読む」との説明がある。

**結論:**  
- `JVRTOpen("0B41", race_key)` で取得できるレコードを **オッズ1（単複枠）構造として読み、その中の複勝オッズ部分だけを抜き出す**実装でよい。
- O1/O2 を dataspec レベルで分けて呼び分ける必要はなく、「O2 = オッズ1レコードの複勝部（時系列用）」とみなせる。

---

## 5. Python 実装例（複勝部のパース）

仕様に沿ったオフセット計算にしておくことで、将来の変更にも追随しやすくなる。

```python
def parse_fuku_odds(buf: bytes, uma_max: int, tansho_start: int) -> dict:
    """
    buf: オッズ1（単複枠）フォーマット1レコード分のバイト列
    uma_max: 最大頭数（仕様上は 28）
    tansho_start: 単勝オッズ部の先頭オフセット（例: 実測 43）
    
    戻り値:
        {馬番(int): (fuku_min(float|None), fuku_max(float|None))}
    """
    
    # 単勝: 1頭8バイト（馬番2 + 単勝オッズ4 + 人気順2）
    fuku_start = tansho_start + uma_max * 8
    
    def to_float4(s: str):
        s = s.strip()
        if not s:
            return None
        if not s.isdigit():
            return None
        v = int(s)
        # 9999 などの特別値の扱いは利用者側ポリシーで調整
        return v / 10.0
    
    result = {}
    for i in range(uma_max):
        off = fuku_start + i * 10  # 複勝は1頭10バイト
        uma = buf[off:off+2].decode("ascii", errors="ignore")
        if not uma.strip():
            continue  # 未使用スロット
        
        raw_min = buf[off+2:off+6].decode("ascii", errors="ignore")
        raw_max = buf[off+6:off+10].decode("ascii", errors="ignore")
        
        fmin = to_float4(raw_min)
        fmax = to_float4(raw_max)
        
        try:
            uma_no = int(uma)
        except ValueError:
            continue
        
        result[uma_no] = (fmin, fmax)
    
    return result
```

この関数に対して:
- `uma_max = 28`（仕様上の最大頭数）
- `tansho_start = 43`（ユーザ環境で確認済みの単勝部開始オフセット）

などを渡せば、複勝オッズ下限・上限を `odds_fuku_min / odds_fuku_max` にそのままマッピングできる形になる。

---

## 6. 2025年12月時点での確認結果

- JV-Data仕様書 Ver 4.9.0.1 本体・変更履歴・データ種別一覧、並びに開発者向け解説記事・フォーラムを再チェックしても、**複勝時系列オッズの構造が上記と矛盾する新しい仕様変更は見当たらない。**
- 従って、
  - 複勝は 1頭あたり **10バイト（馬番2 + 下限4 + 上限4）**
  - オッズ表現は **10倍値の4桁ASCII**
  - 配列順序は **馬番 → 下限 → 上限**
  - 配列開始位置は **単勝部の直後（オフセット = 43 + 8×28 = 267）**
  - dataspec 0B41 で単勝・複勝・枠連の時系列オッズをまとめて取得し、オッズ1（単複枠）として解析する

  という前提は、2025年12月時点でも妥当であり、そのまま採用して問題ないと判断できる。

---

**作成日**: 2025-12-23  
**情報源**: JV-Data仕様書 Ver 4.9.0.1, Perplexity検索結果
